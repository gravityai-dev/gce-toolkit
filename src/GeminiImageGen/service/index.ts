/**
 * Google Gemini Image Generation service
 * Handles all Gemini API interactions with proper credential management
 */

import { GoogleGenAI } from '@google/genai';
import mime from 'mime';
import {
  GeminiImageGenConfig,
  GeminiImageGenCredentials,
  GeneratedImage,
} from "../util/types";
import { getNodeCredentials, geminiLogger as logger } from "../../shared/platform";

type CredentialContext = any;

/**
 * Generate images using Google Gemini's image generation API
 */
export async function generateImages(
  config: GeminiImageGenConfig,
  context: CredentialContext,
  nodeLogger?: any
): Promise<{ images: GeneratedImage[]; text?: string }> {
  // Use provided logger or fall back to base logger
  const log = nodeLogger || logger;

  try {
    // Fetch credentials internally
    const credentials = (await getNodeCredentials(context, "geminiCredential")) as GeminiImageGenCredentials;

    if (!credentials?.apiKey) {
      throw new Error("Gemini API key not found in credentials");
    }

    const apiKey = credentials.apiKey;

    log.info("Calling Gemini Image Generation API", {
      model: config.model,
      promptLength: config.prompt.length,
      numberOfImages: config.numberOfImages || 1,
    });

    // Initialize Gemini client
    const ai = new GoogleGenAI({
      apiKey,
    });

    const geminiConfig = {
      responseModalities: ['IMAGE', 'TEXT'],
    };

    const contents = [
      {
        role: 'user',
        parts: [
          {
            text: config.prompt,
          },
        ],
      },
    ];

    // Make API call using streaming to capture all image chunks
    const response = await ai.models.generateContentStream({
      model: config.model,
      config: geminiConfig,
      contents,
    });

    const images: GeneratedImage[] = [];
    let textResponse = '';
    let fileIndex = 0;

    // Process streaming response
    for await (const chunk of response) {
      if (!chunk.candidates || !chunk.candidates[0].content || !chunk.candidates[0].content.parts) {
        continue;
      }

      // Iterate through all parts in the response
      for (const part of chunk.candidates[0].content.parts) {
        // Extract image data
        if (part.inlineData) {
          const inlineData = part.inlineData;
          const mimeType = inlineData.mimeType || 'image/png';
          const fileExtension = mime.getExtension(mimeType) || 'png';
          const fileName = config.fileName 
            ? `${config.fileName}_${fileIndex}.${fileExtension}`
            : `generated_image_${fileIndex}.${fileExtension}`;

          images.push({
            data: inlineData.data || '',
            mimeType,
            fileName,
          });

          fileIndex++;
          log.info(`Generated image ${fileIndex}`, { fileName, mimeType });
        }
        // Extract text response if any
        else if (part.text) {
          textResponse += part.text;
        }
      }
    }

    if (images.length === 0) {
      throw new Error("No images were generated by Gemini");
    }

    log.info("Gemini image generation successful", {
      model: config.model,
      imageCount: images.length,
      textLength: textResponse.length,
    });

    return {
      images,
      text: textResponse || undefined,
    };
  } catch (error: any) {
    log.error("Failed to generate images", { error: error.message });
    throw new Error(`Failed to generate images: ${error.message}`);
  }
}
